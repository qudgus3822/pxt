<!DOCTYPE html>
<html lang="@locale@" data-manifest="" data-framework="typescript">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
      name="viewport"
      content="width=device-width,height=device-height,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0"
    />
    <script type="text/javascript">
      if (/[&?]translate=1/.test(window.location.href)) {
        var _jipt = [];
        _jipt.push(["project", "makecode"]);
        _jipt.push([
          "escape",
          function () {
            window.location.href = window.location.href.replace(
              /[$\?]translate=1/,
              ""
            );
          },
        ]);
        _jipt.push([
          "before_dom_insert",
          function (text, node, attribute) {
            if (text) text = text.replace(/^\{(id|loc):[^\}]+\}/g, "");
            return text;
          },
        ]);
        // inject crowdin
        (function _() {
          var s = document.createElement("script");
          s.setAttribute("type", "text/javascript");
          s.setAttribute("src", "//cdn.crowdin.com/jipt/jipt.js");
          document.head.insertBefore(s, document.head.firstElementChild);
        })();
      }
    </script>

    <!-- @include appmeta.html -->

    <link
      rel="stylesheet"
      data-rtl="/blb/rtlsemantic.css"
      href="/blb/semantic.css"
      type="text/css"
    />
  </head>

  <body class="main">
    <div id="loading" class="ui active dimmer">
      <div class="ui large main loader msft"></div>
    </div>

    <div id="custom-content"></div>
    <div id="blocks-editor-field-div"></div>

    <div id="allcontent">
      <div id="editorcontent">
        <div id="content" class="ui dimmable full-abs"></div>
      </div>
    </div>

    <div id="msg" aria-live="polite">
      <div id="errmsg" class="ui red inverted segment"></div>
      <div id="warnmsg" class="ui orange inverted segment"></div>
      <div id="infomsg" class="ui teal inverted segment"></div>
      <div id="compilemsg" class="ui ignored info message"></div>
    </div>

    <script>
      // This line gets patched up by the cloud
      var pxtConfig = null;
    </script>
    <!-- @include apptrackingweb.html -->
    <!-- @include apptracking.html -->
    <script type="text/javascript" src="/blb/pxtapp.js"></script>
    <script type="text/javascript" src="/blb/target.js"></script>
    <script id="mainscript" type="text/javascript" src="/blb/main.js"></script>
    <xml id="blocklyToolboxDefinitionCategory" style="display: none">
      <!-- An empty category is required so that Blockly launches in category mode -->
      <category name=""> </category>
    </xml>
    <xml id="blocklyToolboxDefinitionFlyout" style="display: none"> </xml>
    <script>
      // Before loading vs/editor/editor.main, define a global MonacoEnvironment that overwrites
      // the default worker url location (used when creating WebWorkers). The problem here is that
      // HTML5 does not (yet) allow cross-domain web workers, so we need to proxy the instantion of
      // a web worker through a same-domain script
      window.MonacoEnvironment = {
        getWorkerUrl: function (workerId, label) {
          return pxt.webConfig.monacoworkerjs;
        },
      };

      // this get rewritten to blob URLs with SHAs while uploading to the cloud
      // keep in sync with release.manifest and asseteditor.html
      window.MonacoPaths = {
        "vs/loader": "/blb/vs/loader.js",
        "vs/base/worker/workerMain": "/blb/vs/base/worker/workerMain.js",
        "vs/basic-languages/bat/bat": "/blb/vs/basic-languages/bat/bat.js",
        "vs/basic-languages/cpp/cpp": "/blb/vs/basic-languages/cpp/cpp.js",
        "vs/basic-languages/markdown/markdown":
          "/blb/vs/basic-languages/markdown/markdown.js",
        "vs/basic-languages/python/python":
          "/blb/vs/basic-languages/python/python.js",
        "vs/basic-languages/typescript/typescript":
          "/blb/vs/basic-languages/typescript/typescript.js",
        "vs/editor/editor.main.css": "/blb/vs/editor/editor.main.css",
        "vs/editor/editor.main": "/blb/vs/editor/editor.main.js",
        "vs/editor/editor.main.nls": "/blb/vs/editor/editor.main.nls.js",
        "vs/language/json/jsonMode": "/blb/vs/language/json/jsonMode.js",
        "vs/language/json/jsonWorker": "/blb/vs/language/json/jsonWorker.js",
        "vs/language/typescript/tsMode":
          "/blb/vs/language/typescript/tsMode.js",
        "vs/language/typescript/tsWorker":
          "/blb/vs/language/typescript/tsWorker.js",
        "lzma/lzma_worker-min.js": "/blb/lzma/lzma_worker-min.js",
        "smoothie/smoothie_compressed.js":
          "/blb/smoothie/smoothie_compressed.js",
        "blockly.css": "/blb/blockly.css",
        "rtlblockly.css": "/blb/rtlblockly.css",
        "gifjs/gif.js": "/blb/gifjs/gif.js",
        "qrcode/qrcode.min.js": "/blb/qrcode/qrcode.min.js",
        "zip.js/zip.min.js": "/blb/zip.js/zip.min.js",
        "pdf-lib/pdf-lib.min.js": "/blb/pdf-lib/pdf-lib.min.js",
        "music-editor/apple.png": "/blb/music-editor/apple.png",
        "music-editor/burger.png": "/blb/music-editor/burger.png",
        "music-editor/cake.png": "/blb/music-editor/cake.png",
        "music-editor/car.png": "/blb/music-editor/car.png",
        "music-editor/cat.png": "/blb/music-editor/cat.png",
        "music-editor/cherry.png": "/blb/music-editor/cherry.png",
        "music-editor/clam.png": "/blb/music-editor/clam.png",
        "music-editor/computer.png": "/blb/music-editor/computer.png",
        "music-editor/crab.png": "/blb/music-editor/crab.png",
        "music-editor/dog.png": "/blb/music-editor/dog.png",
        "music-editor/duck.png": "/blb/music-editor/duck.png",
        "music-editor/egg.png": "/blb/music-editor/egg.png",
        "music-editor/explosion.png": "/blb/music-editor/explosion.png",
        "music-editor/fish.png": "/blb/music-editor/fish.png",
        "music-editor/ice-cream.png": "/blb/music-editor/ice-cream.png",
        "music-editor/lemon.png": "/blb/music-editor/lemon.png",
        "music-editor/snake.png": "/blb/music-editor/snake.png",
        "music-editor/star.png": "/blb/music-editor/star.png",
        "music-editor/strawberry.png": "/blb/music-editor/strawberry.png",
        "music-editor/taco.png": "/blb/music-editor/taco.png",
        "music-editor/bass-clef.svg": "/blb/music-editor/bass-clef.svg",
        "music-editor/treble-clef.svg": "/blb/music-editor/treble-clef.svg",
      };

      async function receiveMessageCustom(event) {
        if (event.data.type == "capture") {
          const canvas = await html2canvas(document.body, {
            useCORS: true,
            allowTaint: true,
            logging: true,
            scale: 2,
            width: window.innerWidth,
            height: window.innerHeight,
            scrollX: 0,
            scrollY: 0,
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            x: 0,
            y: 0,
            backgroundColor: null,
          });

          canvas.toBlob(function (blob) {
            // Blob을 File 객체로 변환
            const file = new File([blob], "capture.png", { type: "image/png" });
            const object = {
              file: file,
              width: canvas.width,
              height: canvas.height,
            };
            window.parent.postMessage(
              {
                type: "captureComplete",
                content: object,
              },
              "*"
            );
          }, "image/png");
        }

        if (event.data.type == "exportFile") {
          try {
            // // 현재 프로젝트 상태 가져오기
            const state = pxt.editor.getProjectState();

            // 컴파일 서비스 호출
            const resp = await pxt.staticpkg.compileAsync({
              target: pxt.appTarget.id,
              code: state.code,
              dependencies: state.dependencies,
              format: "hex",
            });

            if (resp.success && resp.binary) {
              // hex 파일 다운로드
              const blob = new Blob([resp.binary], {
                type: "application/octet-stream",
              });
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "project.hex";
              a.click();
              window.URL.revokeObjectURL(url);
            }

            window.parent.postMessage(
              {
                type: "projectExported",
                content: {
                  hexFile: hexFile,
                  sourceFile: sourceFile,
                },
              },
              "*"
            );
          } catch (e) {
            console.error(e);
          }
        }

        if (event.data.type == "compileResult") {
          console.log(event.data.content);
        }

        if (event.data.type == "pxteditor") {
        }
      }

      //window.removeEventListener('message', receiveMessage, false);
      window.addEventListener("message", receiveMessageCustom, false);

      window.addEventListener("DOMContentLoaded", () => {
        // 감시할 대상 요소를 선택
        const targetNode = document.getElementById("content");
        // MutationObserver 콜백 함수 정의
        const observerCallback = function (mutationsList, observer) {
          for (const mutation of mutationsList) {
            if (mutation.type === "childList") {
              if (!targetNode) {
                return;
              }

              if (
                targetNode.getElementsByClassName("more-dropdown-menuitem")
                  .length == 0 ||
                targetNode.getElementsByClassName("editortools-github-btn")
                  .length == 0
              ) {
                return;
              }
              targetNode.getElementsByClassName(
                "more-dropdown-menuitem"
              )[0].style.display = "none";
              targetNode.getElementsByClassName(
                "editortools-github-btn"
              )[0].style.display = "none";
              targetNode.getElementsByClassName(
                "signin-button"
              )[0].style.display = "none";
              const elements = document
                .getElementById("downloadArea")
                .getElementsByClassName("link");

              // HTMLCollection을 배열로 변환하여 filter 사용
              const filteredElements = Array.from(elements).map(
                (item, index) => {
                  if (item.getAttribute("title") === "도움말") {
                    return index;
                  }
                }
              );
              if (filteredElements.length > 0) {
                for (const index of filteredElements) {
                  if (!index) {
                    continue;
                  }
                  elements[index].style.display = "none";
                }
                observer.disconnect();
              }
            }
          }
        };

        // MutationObserver 인스턴스 생성
        const observer = new MutationObserver(observerCallback);

        // 옵저버 설정 옵션
        const config = { childList: true, subtree: true };

        // 대상 요소에 대해 옵저버 시작
        observer.observe(targetNode, config);
      });
    </script>
  </body>
</html>
